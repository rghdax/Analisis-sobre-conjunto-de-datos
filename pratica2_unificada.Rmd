---
title: 'Practica 2: Limpieza y análisis de datos'
author: "Daniel Bagan y Rafael García"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
  word_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r librerias a usar, message=FALSE, warning=FALSE}
library(knitr)
library(stringr)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(corrplot)
require(gridExtra)
library(caret)
library(psych)
library(nortest)
```

# 1 Descripción del dataset

Para el desarrollo de esta práctica, se ha seleleccionado el dataset **Listado de películas** extraído en la primera práctica de la asignatura, desde la pagina web Rotten Tomatoes (*https://www.rottentomatoes.com*). Este dataset ha sido publicado en Zenodo con el DOI: 10.5281/zenodo.4265051 y puede ser visualizado en el siguiente link: *https://zenodo.org/record/4265051#.X6mORGgReUk*.

Este juego de datos se ha elegido por varios motivos, además de nuestro interés por el cine. En primer lugar, porque ha sido creado por nosotros mismos como resultado de la primera práctica de la asignatura. En segundo lugar, porque este juego de datos es especialmente apropiado para llevar a cabo el proceso de limpieza; por una parte, un porcentaje elevado de las variables debe ser limpiado para facilitar su tratamiento posterior, y por otra parte, hay una buena cantidad de variables derivadas que se pueden crear a partir de las ya existentes. Por último, porque es adecuado para plantear difrentes tipos de problemas, como regresión (predecir la puntuación de una película), clasificación (clasificar las películas en buenas y malas), o establecer relaciones entre las distintas variables o contrastes de hipótesis, para contestar dudas como: ¿las películas de Netflix son significativamente mejores que las de HBO?, ¿las películas de drama son suelen er más largas que las de comedia? o ¿en invierno se estrenan más películas que en verano?

El juego de datos contiene información sobre todas las películas disponibles en la página web de críticas Rotten Tomatoes. Las variables que contiene son las siguientes:

   - `X`: número de película.
    
   - `Title`: título de la película.
    
   - `Tomatometer`: puntuación (sobre 100%) que otorga la propia página a la película, basada en la opinión de cientos de críticos. Concretamente, se trata del porcentaje de críticos que han puntuado positivamente la película.
    
   - `Audience score`: porcentaje de usuarios de la web que han valorado la película positivamente.
    
   - `Rating`: clasificación por edades de la película y motivo de la clasificación. Por ejemplo, R(SexualContent|SomeDrugMaterial) indicaría una clasificación de “Restringido” (los menores de 17 años acompañados de un adulto) por contenido sexual y drogas.
    
   - `Genre`: género o géneros de la película.
    
   - `Director`: director de la película.
    
   - `Producer`: productor de la película.
    
   - `Writer`: escritor del guión de la película.
    
   - `Release Date (Theaters)`: fecha de lanzamiento en cines.
    
   - `Release Date (Streaming)`: fecha de lanzamiento en streaming.
    
   - `Runtime`: duración de la película.
    
   - `Production Co`: compañía de producción.
   
# 2 Integración y selección de los datos de interés a analizar

En cuanto a las selección de datos de interes a analizar, cabe mencionar que, en el momento de recogida de los datos, ya se realizó una selección de las variables que podrían ser útiles, descartando aquellas sin valor aparente, como `Aspect Ratio`, o con una cantidad de datos vacíos demasiado elevada, como `Box Office`.

Los campos de interés a analizar en los que no se realizará ninguna modificación, salvo una limpieza simple, son: `Title`, `Tomatometer`, `Audience score`, `Rating`, `Director` y `Runtime`.

Los siguientes campos se crearán a partir de otros o se dividirán en varios: 

   - `Fresh`. La página web Rotten Tomatoes otorga la clasificación *Fresh* a la películas con más del 60% de crítica positiva, mientras que las demás son clasificadas como *rotten* (podridas).
    
   - `Parental.Control`: se trata de un atributo categórico dicotómico, creado a partir de la información del campo Rating. Indica si una película tiene alguna restricción de edad o no.
    
   - `Genre`: se dividirá la variable en 3 diferentes: **género primario, secundario y terciario**.
    
   - `Production`: contiene la compañía de producción de la película, o el nombre del productor en caso de que esta no figure en los datos.
    
   - `Release.isWide`: atributo categórico dicotómico. Indica si el estreno de una película ha sido *wide* (estenada en la mayoría de cines simultáneamente) o *limited* (sólo en unos pocos cines). Se obtiene a partir de Release.Date.Theaters.
    
   - `Release.Date`: fecha de lanzamiento de la película, ya sea en cines o streaming.
    
   - `Release.Season`: estación de lanzamiento de la película.
    
   - `DirectorIsWriter`: atributo categórico dicotómico. Indica si el director es también el escritor de la película.
   

# 3 Limpieza de los datos.

A continuación se procederá a realizar la limpieza de cada una de las variables del dataset y en cada una se irá comentando como se gestionaron valores extremos, `NA`, ceros y elementos vacíos. 

En este apartado también se crearán los distintos campos comentados anteriormente,  derivados de la información contenida en el dataset original.

```{r carga de fichero con datos}

df <- read.csv(file="https://raw.githubusercontent.com/
dbagan13/WebScrapping/main/csv/recogiendo_tomates.csv",header=TRUE,sep=",")

# Eliminando columna cargada como X
df <- subset(df, select = -c(X))

#Tratamiento inicial de nulos y cadenas vacías
df$Director[df$Director==""] <- NA
df$Producer[df$Producer==""] <- NA
df$Writer[df$Writer==""] <- NA
df$Production.Co[df$Production.Co==""] <- NA
```

Se eliminó la columna `X` ya que realmente no aporta al análisis. Se le asigno el valor `NA` a todos los registros que contienen cadenas vacias o nulos.

#### 3.1 Limpieza varibale Tomatometer.

```{r Limpieza de variable Tomatometer}

# Eliminando simbolo %
df.Tomatometer <- as.integer(str_remove_all(df$Tomatometer, "%"))

# Agregando la variable Tomatometer sin simbolo al dataset original
df$Tomatometer <- df.Tomatometer 

# Conteo de NA
summary(df$Tomatometer)

# Eliminando NA de Tomatometer
df <- df[complete.cases(df$Tomatometer), ]
```

Para el caso de la variable `Tomatometer`, se decidió remover el simbolo de %, para poder trabajar la variable como números enteros. También, por ser una variable de interés para futuros análisis y que sólo posee 47 `NA`, se decidió eliminar estos registros.

#### 3.2 Creación de la variable Fresh.

Como se comento inicialmente, esta variable se calculará siguiendo el criterio establecido en la propia pág de Rotten Tomatoes; es decir:

- `Fresh` (1) si `Tomatometer` > 60
- `Rotten` si (0) `Tomatometer` <= 60

```{r Creación de la variable Fresh}
# La variable Fresh será igual a 1 cuando el Tomatometer sea > 60 y 0 en caso
# contrario

df.fresh <- df$Tomatometer
df.fresh[df.fresh < 60] <- 0
df.fresh[df.fresh >= 60] <- 1
df$Fresh <- df.fresh
``` 

#### 3.3 Limpieza variable Audience.score.

Al igual que se hizo con la varible `Tomatometer`, a esta varible le quitaremos el simbolo de % y eliminaremos los `NA` (331 registros), ya que esta es también una variable de interés para futuros analásis.

```{r Limpieza variable Audience Score}

# Eliminando simbolo % 
df.Audience.score <- as.integer(str_remove_all(df$Audience.score, "%"))

# Agregando la variable Audience Score sin símbolo al dataset original
df$Audience.score <- df.Audience.score

# conteo de NA 
summary(df$Audience.score)

# Eliminando NA's de variable Audience Score. 
df <- df[complete.cases(df$Audience.score), ] 
```

#### 3.4 Limpieza de variable Rating.

En este caso, limpiaremos la variable tal que solo quede el tipo de clasificación que pertenezca cada pelicula: `G`, `NC-17`, `PG`, `PG-13`, `R`, `TV14`, `TVG`, `TVMA` ó `TVPG`.

Para los casos en que la película no tuviera explícita una categoría, se dicidió asignarles la `G`.

```{r tratamieto de la variable rating}

df.Rating <- str_remove_all(df$Rating, "\\([a-zA-Z \\.,|/&-]*\\)") 

# Agregando la variable Rating al dataframe original
df$Rating <- df.Rating

# Imputando el valor G en los valores vacios de la variable Rating
df$Rating <- na_if(df$Rating, "")
df$Rating[is.na(df$Rating)] <- "G"

levels(factor(df$Rating))
```
#### 3.4.1 Creación de variable Parental.Control

Esta variable se creo a partir de la variable `Rating`. Es una variable dicotómica donde el valor será 1 cuando la película pertenezca a la categoría G (público General) y será 0 cuando la pelicula pertenezca a cualquier otra categoría que requiera de algún tipo de control parental.

```{r Creación variable dicotómica a partir de rating}
p.control <- str_replace_all(df$Rating, "^G", "1")
p.control <- str_replace_all(p.control,"NC-17|PG-13|PG|R|TV14|TVG|TVMA|TVPG",
                                    "0")
p.control <- as.integer(p.control)

df["Parental.Control"] <- p.control
```


A continuación, se presenta un gráfico representantivo para cada una de estas primeras 5 variables:

```{r grafico Tomatomete, Audience.scor, Fresh y Rating}
plot1 <- ggplot(df, aes(Tomatometer)) + geom_histogram(binwidth=2) 
plot2 <- ggplot(df, aes(Audience.score)) + geom_histogram(binwidth = 2) 
plot3 <- ggplot(df, aes(Fresh)) + geom_bar()
plot4 <- ggplot(df, aes(Rating)) + geom_bar()
plot5 <- ggplot(df, aes(Parental.Control)) + geom_bar()

ggarrange(plot1, plot2, plot3)
ggarrange(plot4, plot5)
```

#### 3.5 Tratamiento de variable Genre.

Debido a que una misma película puede tener asignado más de un género, se dividirá esta variable en tres: Genre1, Genre2 y Genre3 y se imputarán en estas los tres principales géneros (si los tuviere) a los que pertenezca la película en cuestión, respectivamente

```{r Tratamiento de la variable Genre}

df.Genre <- df$Genre
# Generación variable Genre1
df.Genre1 <- str_extract(df.Genre, "[a-zA-Z]*")
#df.Genre1

# Generación variable Genre2
df.Genre2 <- str_extract(df.Genre,",[a-zA-Z]*" )
df.Genre2 <- str_remove_all(df.Genre2, ",")
#df.Gen2

# Generación variable Gen3
df.Genre3 <- str_extract(df.Genre, "([a-zA-Z]*,){2}[a-zA-Z]*")
df.Genre3 <- str_extract(df.Genre3, ",[a-zA-Z]*$")
df.Genre3<- str_remove_all(df.Genre3, ",")
#df.Gen3

# Eliminando variable Genre y agregando variables nuevas Gen1, Gen2 y Gen3
# al dataset original
df <- subset(df, select = -c(Genre))
df["Genre1"] <- df.Genre1
df["Genre2"] <- df.Genre2
df["Genre3"] <- df.Genre3
```

#### 3.6 Tratamiento variable Runtime.

El formato original de esta variable era una `string` que represetaba la hora y los minutos tal que, por ejemplo: 1h30m. Este formato se cambió y se colocó la duración de la película en minutos.

En aquellos casos donde existía un valor `NA` se imputó el valor de la media de la variable.

```{r Tratamiento variable Runtime}

horas <- as.integer(substr(df$Runtime, 1, 1))
minutos <- as.integer(substr(df$Runtime, 3, 4)) 
minutos[is.na(minutos)] <- as.integer(str_sub(df$Runtime[is.na(minutos)],
                                              -2, -2)) 
minutos[is.na(minutos)] <- 0
runtime <- 60*horas+minutos
# Para aquellas películas que no tienen Runtime, se les ha colocado la media
runtime[is.na (runtime)] <- mean(runtime, na.rm = TRUE)
df$Runtime <- as.integer(runtime)
```

#### 3.7 Tratamiento de variables Release.Date.Streaming y Release.Date. Theater. Creación de variable Realese.IsWide

```{r Comprobación de características de variables Release Date}
# Corrigiendo nombre de variables.
colnames(df)[8] <- "Release.Date.Theaters"
colnames(df)[9] <- "Release.Date.Streamings"
```

Estas dos variables se usaron en general para la creación de las variables derivadas `Realese.IsWide` y `Seasons`. 

En el caso de Realise.IsWide, las palabras `wide` y `limited` se encontraban dentro de la string correspondiente a la variable `Realese.Date.Theaters`. Así que, en este caso, sólo hubo que filtrar la cadena de texto.

```{r Creación Variable Realise.IsWide}
#Wide o limited
theaters <- df$Release.Date.Theaters
release_type <- df$Release.Date.Theaters
release_type[str_sub(release_type, -4, -1)=="wide"] <- 1
release_type[str_sub(release_type, -7, -1)=="limited"] <- 0
df$Release.isWide <- as.integer(release_type)
```

Para la creación de la variable Seasons realizó una limpieza de las variables `Release.Date.Streaming` y `Release.Date.Theaters` de tal forma que:

- En caso de que un película tuviera ambos campos, se determinó cual de las dos fechas fue primero.
- A través de una transformación de las cadenas de texto, se determinó en que Estación del año fue estrenada la película.

```{r Limpieza variable Release.Date.Streaming}
#Separacion fecha
months <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug","Sep",
            "Oct", "Nov", "Dec" )
streamings.year <-  as.integer(str_sub(df$Release.Date.Streamings, -4, -1)) 
streamings.month <-  substr(df$Release.Date.Streamings, 1, 3)
streamings.day <-  as.integer(gsub(",","",substr(df$Release.Date.Streamings,
                                                 4, 5))) 
streamings.month <- match(streamings.month,months)
streamings.date <- paste(str_sub(streamings.year, -2, -1),streamings.month,
                         streamings.day,sep="/")
streamings.date <- as.Date(streamings.date,format="%D")
```

```{r Limpieza Release.Date.Theaters}
#Limpieza
theaters <- str_remove_all(theaters,"limited")
theaters <- str_remove_all(theaters,"wide")
theaters <- str_sub(theaters, 1, -3)

#Separacion fecha
theaters.year <-  as.integer(str_sub(theaters, -4, -1)) 
theaters.month <-  substr(theaters, 1, 3)
theaters.day <-  as.integer(gsub(",","",substr(theaters, 4, 5))) 
theaters.month <- match(theaters.month,months)
theaters.date <- paste(str_sub(theaters.year, -2, -1),theaters.month,
                       theaters.day,sep="/")
theaters.date <- as.Date(theaters.date,format="%D")
```

```{r selección de primera fecha}
na_date <-  as.Date("68/12/31",format="%D")
theaters.date[is.na(theaters.date)] <- na_date
streamings.date[is.na(streamings.date)] <- na_date
df$Release.Date <- pmin(streamings.date, theaters.date)
df$Release.Date[df$Release.Date==na_date] <- NA
df$Release.YearDay <- as.integer(strftime(df$Release.Date, format = "%j"))
df$Release.Year <- strftime(df$Release.Date, format = "%Y")
```

```{r Creación de variable Seasons}
#Estación
spring <-  as.integer(strftime("2020-03-21", format = "%j"))
summer <-  as.integer(strftime("2020-06-22", format = "%j"))
autumn <-  as.integer(strftime("2020-09-23", format = "%j"))
winter <-  as.integer(strftime("2020-12-22", format = "%j"))
df$Seasons[!is.na(df$Release.Year)] <- "winter"
df$Seasons[df$Release.YearDay>spring] <- "spring" 
df$Seasons[df$Release.YearDay>summer] <- "summer" 
df$Seasons[df$Release.YearDay>autumn] <- "autumn" 
df$Seasons[df$Release.YearDay>winter] <- "winter"
```

Finalmente, se eliminaron las columnas YearDay, Release.Date.Streamings y Release.Date.Theaters.

```{r Eliminando columnas YearDay, Release.Date.Streaming etc}
df$Release.YearDay <- NULL
df$Release.Date.Streamings <- NULL
df$Release.Date.Theaters <- NULL
```


A continuación, se presentará una gráfica representativa de las variables: `Genre1`, `Runtime`, `Release.IsWide` y `Seasons`:

```{r grafica de variables Genre1, warning=FALSE}

plot6 <- ggplot(df, aes(Genre1)) + geom_bar() + coord_flip()
plot7 <- ggplot(df, aes(Runtime)) + geom_boxplot() 
plot8 <- ggplot(df, aes(Seasons)) + geom_bar() 
plot9 <- ggplot(df, aes(Release.isWide)) + geom_bar() 

plot6
ggarrange(plot7, plot8, plot9)
```

De lo observado en los gráficos se puede detallar que:

- El género que más películas tiene es la categoría `drama`
- En cuanto a la duración de las películas, se observa que la media esta al rededor de 100min. Se puede ver que exiten una serie de películas cuya duración es superior a 150min. Aunque estas aparezcan en el gráfico de Boxplot como valores extremos, no se eliminaron ya que son casos posibles.
- En cuanto a la variable `Seasons`, se observa que existe una distribución uniforme a lo largo de todas las estaciones del años. 
- En cuanto a la variable `Release.IsWide`, se observa que existe casi el doble de películas que sólo tiene un estreno local. Sólo al rededor de 2000 películas tuvieron un estreno mundial.


#### 3.8 Tratamiento de variables Director, Producition.Co, Producer y Writer.

Para finalizar la limpieza de los datos, se creará la variable DirectorIsWriter, que servirá para determinar si el director es la misma persona que el escritor. Esto, para posteriores análisis, será interesante.

```{r Creación de variable DirectorIsWriter}

df$Director[df$Director=="" | df$Director=="UnknownDirector"] <- NA

# Creación de variable DirectorIsWriter
df$DirectorIsWriter<- (df$Director == df$Writer)
df$DirectorIsWriter[df$DirectorIsWriter] <- 1
df$DirectorIsWriter[!df$DirectorIsWriter] <- 0

df$Production.Co[is.na(df$Production.Co)] <- df$Producer[is.na(df$Production.Co)]
colnames(df)[9] <- "Production"
df$Writer <- NULL
df$Producer <- NULL
```


#### 3.9 Representación gráfica de relaciones entre variables:

A continuación, se presentará diferentes gráficos con la finalidad de determinar si existe alguna relación entre las variables que se pueda ser observada visualmente:

```{r representación de relaciones, warning=FALSE}
#Representacion de relaciones
plot10 <- ggplot(df, aes(x=Runtime, y=Audience.score)) + geom_point() 
plot11 <- ggplot(df, aes(x=Runtime, y=Tomatometer)) + geom_point() 
plot12 <- ggplot(aes(y = Audience.score, x = Seasons), 
       data = df) + geom_boxplot() + ggtitle("Audience score by season")
plot13 <- ggplot(aes(y = Tomatometer, x = Seasons), 
       data = df) + geom_boxplot() + ggtitle("Tomatometer by season")
plot14 <- ggplot(aes(y = Audience.score, x = DirectorIsWriter), 
       data = df) + geom_boxplot() + ggtitle("Director is writer")
plot15 <- ggplot(aes(y = Tomatometer, x = DirectorIsWriter), 
       data = df) + geom_boxplot() + ggtitle("Director is writer")
plot16 <- ggplot(aes(y = Audience.score, x = Release.Year), 
       data = subset(df,Release.Year>2005)) + geom_boxplot() + 
       ggtitle("Audience score by year") + coord_flip()
plot16 <- ggplot(aes(y = Tomatometer, x = Release.Year), 
       data = subset(df,Release.Year>2005)) + geom_boxplot() + 
       ggtitle("Audience score by year") + coord_flip()
plot17 <- ggplot(aes(y = Audience.score, x = as.factor(Parental.Control)), 
       data = df) + geom_boxplot() + ggtitle("Director is writer")
plot18 <- ggplot(aes(y = Tomatometer, x = as.factor(Parental.Control)), 
       data = df) + geom_boxplot() + ggtitle("Director is writer")

ggarrange(plot10, plot11, plot12, plot13)
ggarrange(plot14, plot15, plot18)
ggarrange(plot16, plot17)

```



# 4 Análisis de los datos.

## 4.1. Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar)

### Correlación

En primer lugar, se realizará un análisis de la correlación entre las variables del juego de datos. Se utilizará una matriz de correlación para estimar las relaciones ente las variables numéricas del juego de datos (`Audience.score`, `Tomatometer` y `Runtime`).

Además se presentarán gráficos con el fin de averiguar las relaciones de las variables con las puntuaciones de las películas y estimar su influencia.

### Regresión

Se realizará un análisis de regresión para predecir la `Audicence.score` de una película. Para ello se escogerán, a partir del análisis de correlación de las variables, cuáles son las variables de entrada que se utilizarán entre `Parental.Control`, `Genre1`, `Director`, `Runtime`, `Production`, `Release.isWide`, `Release.Year`, `Release.Season` y `DirectorIsWriter`.

### Clasificación

Se creará un modelo de clasificación para clasificar las películas según si son *fresh* o *rotten*, es decir, si tienen una crítica mayormente positiva o no (variable `Fresh`). Al igual que en el modelo de regresión, se seleccionarán las variables de entrada entre `Parental.Control`, `Genre1`, `Director`, `Runtime`, `Production`, `Release.isWide`, `Release.Year`, `Release.Season` y `DirectorIsWriter`.

### Contraste de hipótesis

Se realizarán dos contrastes de hipótesis para tratar de responder dos preguntas:

   - ¿Las películas dirigidas por el propio escritor son mejores que las que tienen un director distinto? 
Se utilizarán las variables `Tomatometer` y `DirectorisWriter`.
        
   - ¿En otoño se estrenan más películas de terror que en las demás estaciones?
Se utilizarán las variables `Release.Season` y `Genre1`.

# 4.2 Comprobación de la normalidad y homogeneidad de la varianza.

En este apartado se analizará la normalidad y la homogenidad de la varianza de las variables aleatorias del dataset:

- `Tomatometer`
- `Audience.Score`
- `Runtime`

El resto de variables del dataset son de carácter categórico o dicotómico y por ende no cabe en ellas tales análisis.

Para el estudio de normalidad, procederemos a aplicar tres métodos:

- ***Método gráfico:*** se graficará cada variable junto con una curva de distribución normal con la misma media y desviación estandar que muestra cada una. A partir de esto, se podrá observar si estas variables se asemejan una distribución normal. Además, se graficarán los cuantiles de estas variables junto con los cuantiles teóricos de una distribución normal con misma media y desviación estandar y se evaluará si dichos cuantiles se encuentran más o menos alineados entorno a esta.

- ***Método analítico:*** Se calculará asimetría y curtosis de cada variable y se comprobará si presentan valores similares a los presentes en una distribución normal

- ***Método de contraste:*** Se realizará un test de Anderson-Darling.

Luego, una vez finalizada la aplicación de estos métodos, nos apoyaremos en los resultados obtenidos para llegar a una conclusión sobre la normalidad de estas variables.

## 4.2.1 Aplicación del Método Gráfico:

### Variable: Tomatometer:

```{r metodo grafico normalidad Tomatometer}

# Gráfica de histograma de Tomatometer junto con una curva 
# de distribución normal
plot1 <- ggplot(df, aes(Tomatometer)) +
  geom_histogram(aes(y =..density.., fill =..count..), binwidth = 2) +
  scale_fill_gradient(low = "#C3E4ED", high = "#35586C") +
  stat_function(fun = dnorm, colour = "red",
                args = list(mean = mean(df$Tomatometer),
                            sd = sd(df$Tomatometer))) +
  ggtitle("Histograma con curva normal teórica") +
  theme_bw()

plot2 <- ggqqplot(df, x="Tomatometer", add = "qqline", ggtheme = theme_minimal(),
         title = "QQplot Tomatometer", ylim = c(0,100) )

ggarrange(plot1, plot2)

```
De los gráficos anteriores de la variable `Tomatometer`, se puede señalar lo siguiente:

- En el histograma, visualmente, no se detalla que la variable siga una distribución normal. Existe un comportamiento marcado de gran cantidad de valores entre el 75% y 100%.

- En el gráfico QQ se observa que las películas que poseen un `Tomatometer` entre 12,5% y 87,5% se ajustan bastante bien a la línea recta teórica, pero luego encontramos en ambos extremos que los puntos se separan significativamente de la recta, obteniendo un resultado similar al de una gráfica QQ de una distribución uniforme; esto es: en el extremo derecho los puntos se encuentran por debajo de la recta, indicando que los valores en los datos no son tan extremos como lo serian los esperados por una distribución normal.De forma similar en el lado izquierdo, es decir: no son tan extremos como lo serian los esperados por una distribución normal. Esto se debe a que la variable `Tomatometer` posee como caracteristica el hecho de que se encuentra acotada entre 0 y 100.

###Variable Audience.score:
```{r metodo grafico normalidad Audience Score}

plot1 <- ggplot(df, aes(Audience.score)) +
  geom_histogram(aes(y =..density.., fill =..count..), binwidth = 2) +
  scale_fill_gradient(low = "#C3E4ED", high = "#35586C") +
  stat_function(fun = dnorm, colour = "red",
                args = list(mean = mean(df$Audience.score),
                            sd = sd(df$Audience.score))) +
  ggtitle("Histograma con curva normal teórica") +
  theme_bw()

plot2 <- ggqqplot(df, x="Audience.score", add = "qqline", 
                  ggtheme = theme_minimal(),
         title = "QQplot Audience.score" , ylim = c(0,100))

ggarrange(plot1,plot2)

```
De los gráficos de la variable `Audience.score` se observa:

- En el histograma se detalla un comportamiento similar a una curva de distribución normal.

- En el gráfico QQ se vuelve a observar, al igual que con la variable `Tomatometer`, que en los extremos los datos se separan de la recta. Esto, de nuevo, es debido a la característica propia de la variable de ser acotada entre 0 y 100.

###Variable Runtime
```{r metodo grafico normalidad Runtime}
plot1 <- ggplot(df, aes(Runtime)) +
  geom_histogram(aes(y =..density.., fill =..count..), binwidth = 2) +
  scale_fill_gradient(low = "#C3E4ED", high = "#35586C") +
  stat_function(fun = dnorm, colour = "firebrick",
                args = list(mean = mean(df$Runtime),
                            sd = sd(df$Runtime))) +
  ggtitle("Histograma con curva normal teórica") +
  theme_bw()

plot2 <- ggqqplot(df, x="Runtime", add = "qqline", 
                  ggtheme = theme_minimal(),
         title = "QQplot Runtime" , ylim = c(50,350))

ggarrange(plot1,plot2)
```
De los gráficos de la variable `Runtime` se detalla:

- El histobrama presenta una fuerte concentración de datos aproximadamente entorno a los valores 90 - 100. También se observa una distribución con asimetría hacia la derecha (positiva), presentando una larga cola derecha.

- En el gráfico QQ se comprueba el comportamiento señalado en el histograma: los datos a la derecha de la curva se encuentran significativamente por encima de la recta, lo cual indica que estos poseen valores mucho mayores a los esperados en una distribución normal con media y desviación estandar similar al conjunto de datos.


##4.2.2 Aplicación del método Analítico:

En este apartado se aplicará un estudio de Curtosis y asimetría a cada una de las variables.

###Variable Tomatometer:
```{r método analítico Tomatometer}
# Cálculo de la curtorsis
curtosis <- kurtosi(df$Tomatometer)

# Cálculo de la asimetría
asimetria <- skew(df$Tomatometer)

sprintf("Curtosis: %.3f, Asimetría: %.3f", curtosis, asimetria)
```
Los valores obtenidos, tanto en la curtosis como en la asimetría, estan en el rango de -1 a 1, lo cual señala una leve desviación de la normalidad.


###Variable Audience Score:
```{r método analítico Audience Score}
# Cálculo de la curtorsis
curtosis <- kurtosi(df$Audience.score)

# Cálculo de la asimetría
asimetria <- skew(df$Audience.score)

sprintf("Curtosis: %.3f, Asimetría: %.3f", curtosis, asimetria)
```
Los valores de curtosis y asimetría de la variable `Audience.score` señalan también una leve desviación de la normalidad. Pese a este resultado, todavia se podría considerar como cierto el supuesto de normalidad de esta variable.

###Variable Runtime:
```{r método analítico Runtime}
# Cálculo de la curtorsis
curtosis <- kurtosi(df$Runtime)

# Cálculo de la asimetría
asimetria <- skew(df$Runtime)

sprintf("Curtosis: %.3f, Asimetría: %.3f", curtosis, asimetria)
```
En este caso, tanto la curtosis como la asimetría señalan que no es una curva normal. El valor elevado de la curtosis se debe a la forma "puntiaguda" de la curva producto de la concentración de datos en torno a los valores de 90 y 100. Por su parte, el valor de la asimetría se debe al sesgo derecho que presenta la curva.  

De acuerdo a estos resultados, no se puede aceptar el supuesto de normalidad en esta variable.

##4.2.3 Aplicación del método de contraste.

Debido a que la muestra es mucho mayor a 5000 registros, el test de Shapiro-Wilk no puede ser aplicado en `R`. Por su parte, el test de Kolmogrov-Smirnov, en la documentación correspondiente a su implementación en `R` se señala que este test puede presentar errores si en la data tenemos valores repetidos (que es nuestro caso), es por esto que se usará el test de Anderson-Darling para comprobar la normalidad en estas variables.

Este test tiene como hipótesis nula: ***Los datos tienen una distribución normal***. Así, si el p-valor < nivel de significación (0.05), se rechazará la hipótesis nula.

```{r contando cuantas peliculas de mas de 150 min hay}

# variable Tomatometer.
ad.test(df$Tomatometer)

# variable Audience.score
ad.test(df$Audience.score)

# variable Runtime
ad.test(df$Runtime)

```
Para las tres variables, el p-valor es menor a 0.05, por lo que, de acuerdo a este método de contraste, se debe rechazar el supuesto de normalidad. 

Finalmente, a partir de los métodos utilizados para comprobar la normlidad en las variables, se puede concluir:

- Las variables `Tomatometer`, `Audience.score`  y `Runtime` no poseen una distribución normal. Pese a esto, de acuerdo al teorema del límite central, se puede afirmar que al ser una muestra lo suficientemente grande, la media de la muestra se acerca a la media poblacional.


## 4.2.4 Comprobación de homogeneidad en la varianza.

A continuación, se estudiará la homogeneidad de varianzas utilizando el test de ***Fligner-Killeen***. Este se trata de un método no paramétrico. Es también una alternativa cuando no se cumple la condición de normalidad entre las muertras.

Se aplicará el test de homogeneidad de varianza para conocer si existe variación de esta en:

- Las variables `Tomatometer`, `Audience.score` y `Runtime` , dependiendo si en cada caso la pelicula tiene alguna restricción de control parental o no.

- Las variables `Tomatometer`, `Audience.score` y `Runtime`, dependiendo al `Genre1` que pertenezca la película.

- Las variables `Tomatometer`, `Audience.score` y `Runtime`, dependiendo de la época del año en que fueron estrenadas (variable `Seasons`)

### Homogeneidad en la varianza dependiendo de Parental.control

```{r homogeneidad en la varianza Parental control}
# Para variable Tomatometer
fligner.test(df$Tomatometer ~ df$Parental.Control)

# Para variable Audience.Score
fligner.test(df$Audience.score ~ df$Parental.Control)

# Para variable Runtime
fligner.test(df$Runtime ~ df$Parental.Control)
```
En el caso de muestras divididas a partir de la variable `Parental.Control`, se observa que:

- con respecto a la variable `Tomatometer`, el p-value < 0.05, por lo que se rechaza la hipótesis nula de que exista homogeneidad en la varianza

- con respecto a las variables `Audience.scroe` y `Runtime`, el p-value en ambos casos es mayor a 0.05, por lo que se acepta la hipótesis nula de que la varianza es homogena.

### Homogeneidad en la varianza dependiendo de Genre1

```{r homogeneidad en la varianza Genre1}
# Para variable Tomatometer
fligner.test(df$Tomatometer ~ df$Genre1)

# Para variable Audience.Score
fligner.test(df$Audience.score ~ df$Genre1)

# Para variable Runtime
fligner.test(df$Runtime ~ df$Genre1)
```
Se observa en este caso que para las 24 muestras separadas por el genero al que pertenece cada película, en ninguno de los casos evaluados el p-valor fue superior a 0.05, por lo que se rechaza la posibilidad de homogeneidad en la varianza.

### Homogeneidad en la varianza dependiendo de Seasons

```{r homogeneidad en la varianza Seasons}
# Para variable Tomatometer
fligner.test(df$Tomatometer ~ df$Seasons)

# Para variable Audience.Score
fligner.test(df$Audience.score ~ df$Seasons)

# Para variable Runtime
fligner.test(df$Runtime ~ df$Seasons)
```
Por último, se puede observar que en los 4 grupos formados por la variable `Seasons`, para los casos estudiados observamos que :

- el p-valor en la variable `Tomatometer`es ligeramente superio a 0.05, pero lo suficiente como para aceptar que existe homogeneidad en la varianza.

- el p-valor en la variable `Audience.score` es > 0.05 por lo que nuevamente se acepta lo hipótesis de homogeneidad.

- el p-valor de la variable `Runtime`es inferior a 0.05, por lo que se rechaza la hipótesis de homogeneidad en la varianza.


